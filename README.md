# RISC-V Assembler and Simulator

This repository contains a comprehensive toolchain for the RISC-V architecture, specifically implementing a subset of the **RV32I (32-bit Integer)** instruction set. The project comprises of an assembler and a instruction-level simulator, extended with custom ISA enhancements for specialized computational tasks and bonus aspects of the project.

## Project Overview

The project is designed to facilitate the translation of RISC-V assembly language into machine code and the subsequent execution of that code within a virtualized hardware environment. The toolchain uses the standard RISC-V calling conventions and instruction formats while introducing a "Bonus ISA" to demonstrate the extensibility of the architecture.

## Technical Specifications

### Supported Instruction Formats
The assembler and simulator provide robust support for the following RISC-V instruction types:
*   **R-Type (Register):** Arithmetic and logical operations including `add`, `sub`, `slt`, `srl`, `or`, `and`, and the custom `mul`.
*   **I-Type (Immediate):** Operations with constants and memory loads, including `addi`, `lw`, `jalr`, and the custom `rvrs`.
*   **S-Type (Store):** Memory store operations, specifically `sw`.
*   **B-Type (Branch):** Conditional branching including `beq`, `bne`, and `blt`.
*   **J-Type (Jump):** Unconditional jumps via the `jal` instruction.

### Custom ISA Extensions
Beyond the standard RV32I set, the following instructions are implemented to support advanced hardware-level operations:
*   **mul:** R-type instruction for 32-bit integer multiplication.
*   **rvrs:** I-type instruction that reverses the bitwise order of the source register and stores the result in the destination register.
*   **rst:** A unique hardware primitive that resets all general-purpose registers to zero (excluding the stack pointer).
*   **halt:** A system-level instruction that terminates program execution and triggers a final state dump.

## Toolchain Components

### Assembler (`Assembler.py`)
The assembler utilizes a two-pass logic to ensure accurate compilation:
*   **Pass 1 (Label Resolution):** The source text is scanned to map all labels to their respective memory addresses, calculating the offsets required for branch and jump instructions.
*   **Pass 2 (Binary Generation):** Instructions are parsed, registers are validated against the ABI names, and immediates are checked for overflow before being encoded into 32-bit binary strings.

### Simulator (`Simulator.py`)
The simulator emulates a 32-bit RISC-V processor core with the following architectural components:
*   **Register File:** A set of 32 general-purpose registers, including a hard-wired `zero` register and a stack pointer (`sp`) initialized to a predefined memory address.
*   **Memory Model:** A virtualized memory space where program instructions and data reside. Data memory operations are mapped to a specific segment starting at address `16384`.
*   **Execution Loop:** A fetch-decode-execute cycle that maintains the Program Counter (PC) and updates the architectural state after every instruction.

## Execution and Usage

The tools are implemented in Python and require no external dependencies, ensuring high portability across Linux-based environments.

### Assembler Execution
The assembler reads assembly instructions from a text file and generates a file containing the 32-bit binary representation.
```bash
python Assembler.py <input_assembly_file> <output_binary_file>
```

### Simulator Execution
The simulator consumes the binary machine code and generates two distinct trace files to allow for comprehensive verification.
```bash
python Simulator.py <input_binary_file> <output_binary_trace> <output_decimal_trace>
```
*   **Input Binary File:** The machine code generated by the assembler.
*   **Output Binary Trace:** Contains the 32-bit binary state of the PC and all registers after each instruction, followed by a memory dump.
*   **Output Decimal Trace:** Provides the same state information in a human-readable decimal format for debugging and analysis.

## Implementation Details

### Memory Architecture
The simulator follows the specifications outlined in the project documentation:
*   **Program Memory:** Occupies a 256-byte space, supporting up to 64 instructions.
*   **Data Memory:** Occupies 128 bytes, with the simulation specifically utilizing 32 locations starting at the designated base address.
*   **Stack Pointer:** The `sp` register is initialized to `0x0000017C` (decimal 380) to support standard stack-downwards growth.

### Error Handling
The toolchain includes an `errorGen` suite capable of identifying:
*   Syntactic errors and typos in mnemonics or register names.
*   Immediate values exceeding the allocated bit-width (12-bit or 20-bit).
*   Misuse of labels or incorrect branching offsets.
*   Absence of a `Virtual Halt` instruction, ensuring safe termination of the simulation.
